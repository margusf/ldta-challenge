grammar ee.cyber.simplicitas.oberonexample.Oberon;

scalaheader {
import OberonExtras._
}

Module:
    "MODULE" name1=Id ";"
        decl=Declarations
        ("BEGIN"
            StatementSequence)?
    "END" name2=Id ".";

StatementSequence: first=Statement (";" rest=Statement)*;

ConstantDef: name=Id EqOp CompExpr ";";
VarDef: vars=IdentList ":" varType=Type ";";
ProcedureDecl:
    "PROCEDURE" name=Id
        ("(" (firstParam=FormalParam (";" rest=FormalParam)*)? ")")?
    ";"
    decl=Declarations
    ("BEGIN"
        body=StatementSequence)?
    "END" name2=Id;
FormalParam: pVar="VAR"? ids=IdentList ":" pType=Type;

Declarations:
    ("CONST"
        consts=ConstantDef*)?
    ("TYPE"
        /* TODO */)?
    ("VAR"
        vars=VarDef*)?
    (procedures=ProcedureDecl ";")*;

// factor = ident selector | number | "(" expression ")" | "~" factor.
// term = factor {("*" | "DIV" | "MOD" | "&") factor}.
// SimpleExpression = ["+"|"-"] term {("+"|"-" | "OR") term}.
// expression = SimpleExpression
// [("=" | "#" | "<" | "<=" | ">" | ">=") SimpleExpression].

CompExpr
    returns Expression {makeBinary(op, left, right)}
    : left=SimpleExpr (op=CompOp right=SimpleExpr)?;
option CompOp {def text: String}: EqOp | OtherCompOps;
terminal EqOp: "=";
terminal OtherCompOps: "#" | "<" | "<=" | ">" | ">=";

// TODO: fix issue 2869
option SimpleExpr returns Expression: PosExpr | NegExpr | PlusExpr;

PosExpr
    returns Expression {Unary(UnaryOp.Pos, arg)}
    : PlusOp arg=PlusExpr;
terminal PlusOp: "+";
terminal MinusOp: "-";
terminal OrOp: "OR";
NegExpr
    returns Expression {Unary(UnaryOp.Neg, arg)}
    : MinusOp arg=PlusExpr;
PlusExpr
    returns Expression {makeBinary(ops, first :: rest)}
    : first=Term (ops=PlusExprOp rest=Term)*;
option PlusExprOp
    {def text: String}
    : PlusOp | MinusOp | OrOp;

Term
    returns Expression {makeBinary(ops, first :: rest)}
    : first=Factor (ops=TermOp rest=Factor)*;
terminal TermOp: "*" | "DIV" | "MOD" | "&";
option Factor returns Expression:
    Lhs
    | NumberLit
    | ParenExpr
    | NotExpr;

option Lhs returns Expression:
    Id  // This is necessary to make Id inherit from Expression
    | SelectorExpr;

SelectorExpr
    returns Expression {makeSelector(id, selectors)}
    : id=Id selectors=SelectorPart+;
option SelectorPart: RecordSelector | ArraySelector;
RecordSelector: "." Id;
ArraySelector: "[" index=PlusExpr "]";

terminal NumberLit: ('0' .. '9')+;
ParenExpr returns Expression {expr}: "(" expr=CompExpr ")";
NotExpr
    returns Expression {Unary(UnaryOp.Not, expr)}
    : "~" expr=Factor;

option Type: Id | ArrayType | RecordType;
ArrayType: "ARRAY" count=PlusExpr "OF" baseType=Type;
RecordType: "RECORD" (first=RecordField (";" rest=RecordField)*)? "END";
RecordField: idents=IdentList ":" fieldType=Type;

IdentList: first=Id ("," rest=Id)*;

option Statement:
    Assignment
    | ProcedureCall
    | IfStatement
    | WhileStatement;

Assignment: left=Lhs ":=" right=CompExpr;
ProcedureCall:
    proc=Id /* TODO: Selector* */  // WTF is selector doing here?
        ("(" first=CompExpr ("," rest=CompExpr)* ")")?;

IfStatement:
    "IF" cond=CompExpr "THEN"
        ifStmt=StatementSequence
    ("ELSIF" elsifCond=CompExpr "THEN"
        elsifStmt=StatementSequence)*
    ("ELSE"
        elseStmt=StatementSequence)?
    "END";

WhileStatement:
    "WHILE" cond=CompExpr "DO"
        body=StatementSequence
    "END";

terminal Id: ('a'..'z'|'A'..'Z') ('a'..'z'|'A'..'Z'|'0'..'9')*;
fragment MlComment: '/*' (~'*' | '*' ~'/')* '*/';
fragment SlComment: '//' ~('\n'|'\r')*;
hidden terminal WS: (' '|'\t'|'\r'|'\n'|SlComment|MlComment)+;
